# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_eda.ipynb.

# %% auto 0
__all__ = ['palet', 'seed_everything', 'print_competition_data', 'get_train_pivot', 'get_train_df', 'count_pct',
           'get_classification_df', 'rle2mask', 'make_mask', 'mask2rle', 'plot_mask_image', 'plot_defected_image',
           'get_random_idx', 'show_defects']

# %% ../nbs/01_eda.ipynb 6
from fastai.vision.all import *
import numpy as np
import pandas as pd
import cv2
from matplotlib import pyplot as plt

# %% ../nbs/01_eda.ipynb 8
palet = [
    (249, 192, 12), # ClassId 1
    (0, 185, 241),  # ClassId 2
    (114, 0, 218),  # ClassId 3
    (249,50,12)     # ClassId 4
]

# %% ../nbs/01_eda.ipynb 9
def seed_everything(seed=69):
    """
    Seeds `random`, `os.environ["PYTHONHASHSEED"]`,
    `numpy`, `torch.cuda` and `torch.backends`.
    """
    warnings.filterwarnings("ignore")
    random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)
    np.random.seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True

# %% ../nbs/01_eda.ipynb 11
def print_competition_data(p: Path):
    for elem in p.ls():
        print(elem)

# %% ../nbs/01_eda.ipynb 21
def get_train_pivot(df):
    """
    Summarize the training csv with ClassId as columns and values EncodedPixels
    """
    def rles2classids(s: pd.Series):
        classids = []
        for classid in s.index:
            if classid != "n":
                value = s[classid]
                if not (value is np.nan): 
                    classids.append(str(classid))
        return " ".join(classids)

    train_pivot = df.pivot(
        index="ImageId", columns="ClassId", values="EncodedPixels")
    train_pivot["n"] = train_pivot.notnull().sum(1)
    train_pivot["ClassIds"] = train_pivot.apply(rles2classids, axis=1)
    return train_pivot

def get_train_df(path, only_faulty=False, pivot=False, hard_negatives=False):
    """
    Get training DataFrame with all the images in data/train_images.
    Returns only the faulty images if `only_faulty`.
    """
    img_path = path/"train_images"
    csv_file_name = path/"train.csv"
    
    train = pd.read_csv(csv_file_name)
    
    img_names = [img.name for img in get_image_files(img_path)]    
    df_all = pd.DataFrame({'ImageId': img_names})
    
    train_all = pd.merge(df_all, train, on="ImageId", how="outer", indicator=True)
    
    # Renaming and fillna
    train_all.rename(columns={'_merge': 'status'}, inplace=True)
    rename_dict = {"both": "faulty", "left_only": "no_faulty", "right_only": "missing"}
    train_all["status"] = train_all["status"].cat.rename_categories(rename_dict)
    train_all = train_all[train_all["status"]!="missing"]

    train_all.ClassId.fillna(0, inplace=True)
    train_all.ClassId = train_all.ClassId.astype('int64')
    
    train_all.EncodedPixels.fillna(-1, inplace=True)
    train_all["ImageId_ClassId"] = train_all["ImageId"] + "_" + train_all["ClassId"].astype('str')
    
    if hard_negatives:
        hard_neg_patterns = pd.read_csv(
            path/"hard_negatives_patterns.txt", header=None, names=["ImageId"])
        cond = train_all["status"]=="faulty"
        cond_hn = train_all["ImageId"].isin(hard_neg_patterns["ImageId"].tolist())
        train_all = train_all.loc[cond | cond_hn]
    if only_faulty:
        train_all = train_all[train_all["status"]=="faulty"]
    if pivot:
        return get_train_pivot(train_all)
        
    return train_all 

# %% ../nbs/01_eda.ipynb 31
def count_pct(df, column="ClassId"):
    """Returns a `pandas.DataFrame` with count and frequencies stats for `column`."""
    class_count = df[column].value_counts().sort_index()
    class_count.index.set_names(column, inplace=True)
    class_count = class_count.to_frame()
    class_count.rename(columns={column: "num"}, inplace=True)
    return class_count.assign(freq=lambda df: df["num"] / df["num"].sum())

# %% ../nbs/01_eda.ipynb 49
def get_classification_df(df: pd.DataFrame):
    """
    Get the DataFrame for the multiclass classification model
    """

    def assign_multi_ClassId(x):
        """Returns a string with multi ClassId sep with a blank space (' ')"""
        def fill_cols(c):
            return c.fillna(5).astype('int64').astype(str)

        cols = [fill_cols(x[i]) for i in range(5)]
        cols = [col.replace('5', '') for col in cols]
        ClassId_multi = cols[0] + " " + cols[1] + " " + \
            cols[2] + " " + cols[3] + " " + cols[4]
        ClassId_multi = ClassId_multi.str.strip()
        ClassId_multi = ClassId_multi.str.replace('  ', ' ')

        return ClassId_multi.str.strip()

    train_multi = df.pivot(
        index="ImageId", columns="ClassId", values="ClassId")
    train_multi = train_multi.assign(
        ClassId_multi=lambda x: assign_multi_ClassId(x))
    return train_multi.reset_index()[["ImageId", "ClassId_multi"]]

# %% ../nbs/01_eda.ipynb 58
def rle2mask(rle, value=1, shape=(256,1600)):
    """
    mask_rle: run-length as string formated (start length)
    shape: (width,height) of array to return 
    Returns numpy array, 1 - mask, 0 - background
    Source: https://www.kaggle.com/paulorzp/rle-functions-run-lenght-encode-decode
    """
    s = rle.split()
    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]
    starts -= 1
    ends = starts + lengths
    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)
    for lo, hi in zip(starts, ends):
        img[lo:hi] = value
    return img.reshape((shape[1], shape[0])).T

# %% ../nbs/01_eda.ipynb 65
def make_mask(item, df, flatten=False):
    '''
    Given an item as:
    - row index [int] or
    - ImageId [str] or
    - file [Path] or
    - query [pd.Series],

    returns the image_item and mask with two types of shapes:
    - (256, 1600) if `flatten`,
    - (256, 1600, 4) if not `flatten`,
    '''
    if isinstance(item, str):         cond = df.loc[item]
    elif isinstance(item, int):       cond = df.iloc[item]
    elif isinstance(item, Path):      cond = df.loc[item.name]
    elif isinstance(item, pd.Series): cond = df.loc[item["ImageId"]]
    else:
        print(item, type(item))
        raise KeyError("invalid item")

    fname = cond.name
    # without 0 ClassId, only 1,2,3,4 ClassId
    labels = cond[1:-2]

    h, w = (256, 1600)
    masks = np.zeros((h, w, 4), dtype=np.float32) # 4:class 1～4 (ch:0～3)

    for itemx, label in enumerate(labels.values):
        if label is not np.nan:
            masks[:, :, itemx] = rle2mask(rle=label, value=1, shape=(h,w))

    if flatten:
        classes = np.array([1, 2, 3, 4])
        masks = (masks * classes).sum(-1)

    return fname, masks

# %% ../nbs/01_eda.ipynb 66
def mask2rle(mask):
    """
    Efficient implementation of mask2rle, from @paulorzp
    
    img: numpy array, 1 - mask, 0 - background
    Returns run length as string formated
    Source: https://www.kaggle.com/xhlulu/efficient-mask2rle
    """
    pixels = mask.T.flatten()
    pixels = np.pad(pixels, ((1, 1), ))
    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1
    runs[1::2] -= runs[::2]
    return ' '.join(str(x) for x in runs)

# %% ../nbs/01_eda.ipynb 69
def plot_mask_image(name: str, img: np.array, mask: np.array):
    """Plot a np.array image and mask with contours."""
    fig, ax = plt.subplots(figsize=(15, 5))
    mask = mask.astype(np.uint8)
    for ch in range(4):
        contours, _ = cv2.findContours(mask[:, :, ch], cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
        for i in range(len(contours)):
            cv2.polylines(img, contours[i], True, palet[ch], 2)

    ax.set_title(name, fontsize=13)
    ax.imshow(img)
    plt.xticks([])
    plt.yticks([])
    plt.show()

# %% ../nbs/01_eda.ipynb 70
def plot_defected_image(img_path: Path, df: pd.DataFrame, class_id=None):
    """Plot a `img_path` Path image from the training folder with contours."""
    img_name = img_path.name
    img = cv2.imread(str(img_path))
    _, mask = make_mask(img_path, df)
    class_ids = np.arange(1, 5)
    cond = np.argmax(mask, axis=0).argmax(axis=0) > 0
    classid = class_ids[cond]
    if class_id is None:
        title = f"Original: Image {img_name} with defect type: {list(classid)}"
        plot_mask_image(title, img, mask)
    else:
        title = f"Original: Image {img_name} with defect type {class_id}"
        idx = class_id-1
        filter_mask = np.zeros((256, 1600, 4), dtype=np.float32)
        filter_mask[:, :, idx] = mask[:, :, idx]
        plot_mask_image(title, img, filter_mask)

# %% ../nbs/01_eda.ipynb 71
def get_random_idx(n: int) -> np.ndarray:
    """
    Return a random sequence of size `n`.
    """
    rng = np.random.default_rng()
    return rng.permutation(n)

# %% ../nbs/01_eda.ipynb 73
def show_defects(path, df, class_id=None, n=20, only_defects=True, multi_defects=False):
    """
    Plot multiple images.
    Attributes:
    `path`: [Path]
    `df`: [pd.DataFrame] only train_pivot
    `class_id`: [str or int] select a type of defect otherwise plot all kinds;
    `n`: select the number of images to plot;
    `only_defects` [bool, default True]: if False it shows even the no faulty images;
    `multi_defects` [bool, default False]: if True it shows imgs with multi defects.
    """
    cond_no_defects = df[0] == -1
    cond_multi_defects = df["n"] > 1

    df = df.loc[cond_no_defects] if not only_defects else df.loc[~cond_no_defects]
    df = df.loc[cond_multi_defects] if multi_defects else df.loc[~cond_multi_defects]
    
    if class_id is not None:
        cond_classId = df[class_id].notna()
        df = df.loc[cond_classId]

    imgid_from_df = df.index.tolist()
    pfiles_list = L([path / "train_images" / imgid for imgid in imgid_from_df])
    perm_paths = pfiles_list[get_random_idx(len(pfiles_list))]

    for img_path in perm_paths[:n]:
        plot_defected_image(img_path, df)
